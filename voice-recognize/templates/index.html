<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Voice Analysis</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 20px auto; padding: 20px; }
        button { padding: 10px 20px; margin: 10px; cursor: pointer; }
        #timer { margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Voice Analysis Interface</h1>

    <!-- Mode selection -->
    <div>
        <label><input type="radio" name="mode" value="speech_accuracy" checked> Speech Accuracy</label>
        <label><input type="radio" name="mode" value="conversation"> Conversation</label>
        <label><input type="radio" name="mode" value="practice"> Practice Mode</label>
    </div>

    <!-- Inputs for specific modes -->
    <div id="speechAccuracyInputs">
        <input type="text" id="targetPhrase" placeholder="Enter target phrase">
    </div>
    <div id="conversationInputs" style="display:none;">
        <input type="text" id="question" placeholder="Enter question">
    </div>
    <div id="practiceInputs" style="display:none;">
        <input type="text" id="practiceText" placeholder="Enter your practice text">
        <button onclick="submitPractice()">Submit Practice</button>
    </div>

    <!-- Recording interface (hidden for practice mode) -->
    <div id="recordSection">
        <button id="recordButton" onclick="toggleRecording()">Start Recording</button>
        <div id="timer" style="display: none;">Recording Time: <span id="timeCount">0</span>s</div>
    </div>

    <!-- Display results -->
    <div id="results"></div>

    <script>
        // Mode switching
        document.querySelectorAll('input[name="mode"]').forEach(radio => {
            radio.addEventListener('change', () => {
                const mode = radio.value;
                document.getElementById('speechAccuracyInputs').style.display = (mode === 'speech_accuracy') ? 'block' : 'none';
                document.getElementById('conversationInputs').style.display = (mode === 'conversation') ? 'block' : 'none';
                document.getElementById('practiceInputs').style.display = (mode === 'practice') ? 'block' : 'none';
                document.getElementById('recordSection').style.display = (mode === 'practice') ? 'none' : 'block';
            });
        });

        let mediaRecorder;
        let audioChunks = [];
        let timerInterval;
        let isRecording = false;
        let recordingStartTime = 0;
        const recordButton = document.getElementById('recordButton');
        const timerDiv = document.getElementById('timer');
        const timeCount = document.getElementById('timeCount');
        const resultsDiv = document.getElementById('results');

        async function toggleRecording() {
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm; codecs=opus' });
                    
                    mediaRecorder.ondataavailable = event => {
                        audioChunks.push(event.data);
                    };
                    mediaRecorder.start();
                    isRecording = true;
                    recordButton.textContent = "Stop Recording";
                    timerDiv.style.display = "block";
                    recordingStartTime = Date.now();
                    timerInterval = setInterval(() => {
                        const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                        timeCount.textContent = elapsed;
                    }, 1000);
                } catch (error) {
                    alert("Error accessing microphone: " + error);
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
                recordButton.textContent = "Start Recording";
                timerDiv.style.display = "none";
                clearInterval(timerInterval);
                // Once stopped, process the recording:
                mediaRecorder.onstop = processRecording;
            }
        }

        async function processRecording() {
            const blob = new Blob(audioChunks, { type: 'audio/webm' });
            audioChunks = [];
            const formData = new FormData();
            formData.append('audio', blob, 'recording.webm');
            const mode = document.querySelector('input[name="mode"]:checked').value;
            formData.append('mode', mode);
            if (mode === 'speech_accuracy') {
                formData.append('target', document.getElementById('targetPhrase').value);
            } else if (mode === 'conversation') {
                formData.append('question', document.getElementById('question').value);
            }
            try {
                const response = await fetch('/analyze', { method: 'POST', body: formData });
                const data = await response.json();
                if (data.error) {
                    resultsDiv.textContent = "Error: " + data.error;
                } else {
                    displayResults(data);
                }
            } catch (error) {
                resultsDiv.textContent = "Error: " + error.message;
            }
        }

        async function submitPractice() {
            const practiceText = document.getElementById('practiceText').value;
            const formData = new FormData();
            formData.append('mode', 'practice');
            formData.append('practice_text', practiceText);
            try {
                const response = await fetch('/analyze', { method: 'POST', body: formData });
                const data = await response.json();
                if (data.error) {
                    resultsDiv.textContent = "Error: " + data.error;
                } else {
                    displayResults(data);
                }
            } catch (error) {
                resultsDiv.textContent = "Error: " + error.message;
            }
        }

        function displayResults(data) {
            let output = "";
            if (data.text) {
                output += "Recognized Text: " + data.text + "\n";
            }
            if (data.accuracy !== undefined) {
                output += "Accuracy: " + data.accuracy + "%\n";
            }
            if (data.emotion) {
                output += "Emotion: " + data.emotion + "\n";
            }
            if (data.confidence !== undefined) {
                output += "Confidence: " + (data.confidence * 100).toFixed(1) + "%\n";
            }
            if (data.relevance) {
                output += "Relevance: " + data.relevance + "\n";
            }
            if (data.audio_features) {
                output += "Duration: " + data.audio_features.duration.toFixed(2) + "s\n";
                output += "Pitch Mean: " + data.audio_features.pitch_mean.toFixed(2) + "\n";
                output += "Pitch Variation: " + data.audio_features.pitch_std.toFixed(2) + "\n";
            }
            if (data.suggestions && data.suggestions.length > 0) {
                output += "\nSuggestions:\n";
                data.suggestions.forEach(s => output += "- " + s + "\n");
            }
            resultsDiv.textContent = output;
        }
    </script>
</body>
</html>
